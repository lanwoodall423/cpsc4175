Allen Woodall
8/25/17
Software Engineering
Charles Carter


1. The four components of the software crises were being over budget, being late, having residual faults, and having fewer features or functionality than needed.
2. The primary difference between software life cycle and software development cycle is that the development cycle is primarily for the development of the software with development following release being described as maintenance.
3. Perfective maintenance involves changes that the client believes will improve the effectiveness of the software such as additional functionality or reduced response time. Adaptive maintenance involves changes that are needed due to change in hardware or government regulation etc. Essentially changes needed due to outside changes or changes in the software environment. These seem to be more imperative opposed to perfective maintenance which simply adds on or makes the software better. Adaptive is essential to the survival of the software.
4. Hardware will degrade. It is inherent that it will break eventually. Software should only get better through development. As software engineers we strive to eliminate all flaws and optimize the software through its lifecycle. 
5. The statements highlight the importance of proper software design. If you design the software efficiently and as optimally as possible, it’ll save trouble down the road. 
6. The planning, testing, and documentation phases are one in the same because they’re all necessary and intertwined at every step of development to ensure well designed and well-understood software is created.
7. Object Oriented programming evolved from structured languages so it goes without saying that structural programming is an essential part of its successor. Examples of OOD’s inheritance would include loops and conditionals. 
8. The users probably need to be interacted with more since they’ll be using the software however it must be made to the specifications of the client and at the end of the day it is their product. I think this really depends on the situation. If the users have knowledge you need that the client doesn’t, I think you’d probably interact with the users more.
9. I think game design/programming/development is a good path for daily practice in coding and perceptual learning. It’s a vast knowledgescape and there are enough techniques and methods to spend a lifetime learning. From the simplest things to the most complex. 
10. The piece is truly remarkable. The quote “given enough eyeballs all bugs become shallow” will remain with me. I hadn’t considered the miracle/precedent that Linux was and is even as I’ve used it. I have a newfound appreciation for the power of open-source. I don’t think it should in competition to the traditional cathedral building because they’re both beautiful approaches that are simply different. This piece has made me want to contribute to an open-source project.