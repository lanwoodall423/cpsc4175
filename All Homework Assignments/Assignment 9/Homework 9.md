
## Allen Woodall
## Software Engineering
## Homework 9

1. I think they both play a significant role. Human error is inevitable and is part of the process of refinement. One doesn't sit down a write out a perfect solution. The goal would of course to be to plan and test well and not have to go back but I believe it's typically inevitable and many of our problem domains are complex so this is somewhat justified. Changing requirements are certainly important as well and perhaps an additional requirements could be overlooked until the design phase where you see how things will actually work together. I would hope the most backtracking would be done between design/analysis and testing/implementation, preferably the prior. 
2. I suppose this means that one does iterate through the process but it isn't incremental meaning you don't build on previous runthroughs of the process. It's a single iteration through the process. 
3. I used stepwise refinement to some degree when writing a script to update a set of Google sheets that were orders in an order system I created by extending the workbook with various scripts. The goal was to take in each order sheet's status and update a master order list to reflect it nightly. It required such refinement because there were a great many orders and the script was limited to something like 6 minutes as that's the hard limit Google has in place.  
4. The requirements are subject to change throughout the process as the software evolves so it should be in each increment. Iteration one will surely be flawed and underdeveloped so testing would be more valuable and time effective from the second increment on. 
5. I would explain that it's like a nested loop of two levels. You iterate through the process and its 
6. I think this is a good principle to follow because it ensures you document everything as you go. To implement this in my personal manner of development I would simply be sure to document sections of code as soon as I felt it was complete.
7. Currently I identify most with the Spiral Life-Cycle model. That's what I'm using for my current project and frankly it's the model that makes the most sense to me. I like the idea that you have several opportunities to reattempt each section of the process with previous knowledge. 
8.
