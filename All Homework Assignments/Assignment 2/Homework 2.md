## Allen Woodall
## Software Engineering
## Homework 2

1. The first step in creating a piece of software is precise analysis of the client’s need(s).
2. The client often doesn’t know how their systems work. They often know their problem but don’t know a proper/optimal solution. It’s up to the software engineer to identify what the software actually needs to do based on his/her analysis of the client’s situation opposed to taking the client’s word on what they need.
3. A software engineer can be thought of as a generalist in regard to the need for him/her to gain understanding of the domains they work in in order to determine a proper solution. For example, if making software for a hospital one doesn’t need intimate knowledge of brain surgery but a general understanding of the hospital’s workflow could be necessary. Essentially a software engineer may need to delve into many domains and therefore be a general purpose developer.
4. Direct Observation - Things aren’t always as they appear. Interviewing - People aren’t perfect. They can give incorrect information. They’re also probably not Software Engineers meaning what they think is best for the software isn’t necessarily best. Questionnaire - They’re limited in depth. You can’t question the answers the users provide without guessing at their responses beforehand which isn’t typically practical.
5. Software requirements are dynamic in that when you’re determining them they’re subject to change and development. This is particularly true the more complex will be. For example it may be determined that additional requirements are needed when interviewing for information.
6. Functional requirements are specific actions/functions the software must be able to perform. Non-functional requirements are properties the program must have such as what platform it runs on, a maximum time to perform an action, or anything that isn’t something that it does but rather a non-functional property.
7. It’s a way of visually portraying a system through diagrammatic notation. There are symbols for entities and actions which allow you to map the interactions and flow of a system. The case study didn’t map out the specific functions of the software in this manner. It had a diagram for higher level function but not specifics.
8. From what I’ve read, one of the main concerns is essentially creating rigidness in the development of the product. When a prototype is created and the customer agrees on it there’s a tendency to want to stick to the prototype even though it was developed so early, possibly before the requirements are fully determined. This can inhibit innovation or beneficial large changes.
9. Team one better have done a spot on job if their requirements aren’t changing much. Team two is at least developing their requirements showing that progress is being made. My understanding is that there’s a lot of evolution with determining these requirements partially because they need to be extremely specific. I would rather be team two with a quickly evolving set of requirements than team one that lacks change.
10. The requirements are the core blueprint of the software. They are the groundwork for the program. If they aren’t optimal then there’s room for error down the road. They also require a very different skillset than programming which could be why mistakes are commonly made in them. They require social interaction and talking with people who probably don’t develop software who also probably would like to go with whatever you suggest.
